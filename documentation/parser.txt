Uppercase are nonterminals
Lowercase are terminals

S -> PACKAGE IMPORT CLASS

PACKAGE -> package PACKAGE_PATH | epsilon
PACKAGE_PATH -> id; | id.PACKAGE_PATH

IMPORT -> import IMPORT_PATH | epsilon
IMPORT_PATH -> IMPORT_PATH_END | id.IMPORT_PATH
IMPORT_PATH_END -> id; | id.*;

CLASS -> CLASS_SCOPE class class_id  { CLASS_CODE }
CLASS_SCOPE -> public | abstract | final | epsilon

CLASS_CODE -> CLASS_VARIABLE CLASS_CODE | METHOD CLASS_CODE | epsilon

CLASS_VARIABLE -> CLASS_VARIABLE_DECLARATION; | CLASS_VARIABLE_DECLARATION = INSTANTIATION;

CLASS_VARIABLE_DECLARATION -> CLASS_VARIABLE_SCOPE STATIC FINAL TYPE variable_id ARRAY

CLASS_VARIABLE_SCOPE -> public | private | protected | epsilon

METHOD -> METHOD_SCOPE STATIC METHOD_TYPE ARRAY method_id ( PARAMETERS ) { METHOD_CODE }
METHOD_SCOPE -> public | private | protected | epsilon

STATIC -> static | epsilon

ARRAY -> [] ARRAY | epsilon

FINAL -> final | epsilon

METHOD_TYPE -> PRIMITIVE | OBJECT | void

PRIMITIVE -> int | char | byte | double | float | boolean | short | long

PARAMETERS -> PARAMETER | epsilon

PARAMETER -> FINAL PARAMETER_TYPE ARRAY parameter_id COMMA PARAMETERS

PARAMETER_TYPE -> PRIMITIVE | OBJECT

COMMA -> , | epsilon

OBJECT -> OBJECT_ID ARRAY | OBJECT_ID <OBJECT> ARRAY

OBJECT_ID -> object_id | GENERIC_ID

GENERIC_ID -> generic_id | ?

METHOD_CODE -> METHOD_VARIABLE METHOD_CODE | epsilon

METHOD_VARIABLE -> METHOD_VARIABLE_DECLARATION; | METHOD_VARIABLE_DECLARATION = INSTANTIATION;

METHOD_VARIABLE_DECLARATION -> FINAL TYPE variable_id

// note will have to figure out a solution for generic wildcard as the generic wildcard cannot
// always be inserted for all GENERIC_IDs

// will have to consider implementing an attribute grammar to check, or will have to
// make less broad rules