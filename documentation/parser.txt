Uppercase are nonterminals
Lowercase are terminals

S -> PACKAGE IMPORT CLASS

PACKAGE -> package PACKAGE_PATH | epsilon
PACKAGE_PATH -> id; | id.PACKAGE_PATH

IMPORT -> import IMPORT_PATH | epsilon
IMPORT_PATH -> IMPORT_PATH_END | id.IMPORT_PATH
IMPORT_PATH_END -> id; | id.*;

CLASS -> CLASS_SCOPE class class_id  { CLASS_CODE }
CLASS_SCOPE -> public | abstract | final | epsilon

CLASS_CODE -> CLASS_VARIABLE CLASS_CODE | METHOD CLASS_CODE | epsilon

CLASS_VARIABLE -> CLASS_VARIABLE_SCOPE STATIC TYPE variable_id ARRAY; | CLASS_VARIABLE_SCOPE STATIC TYPE variable_id ARRAY = INSTANTIATION;

CLASS_VARIABLE_SCOPE -> public | private | protected | epsilon

METHOD -> METHOD_SCOPE STATIC TYPE ARRAY method_id ( PARAMETERS ) { METHOD_CODE }
METHOD_SCOPE -> public | private | protected | epsilon

STATIC -> static | epsilon

ARRAY -> [] ARRAY | epsilons

TYPE -> PRIMITIVE | OBJECT | void

PRIMITIVE -> int | char | byte | double | float | boolean | short | long

PARAMETERS -> epsilon

OBJECT -> OBJECT_ID ARRAY | OBJECT_ID <OBJECT> ARRAY

OBJECT_ID -> object_id | GENERIC_ID

GENERIC_ID -> generic_id | ?

// note will have to figure out a solution for generic wildcard as the generic wildcard cannot
// always be inserted for all GENERIC_IDs

// will have to consider implementing an attribute grammar to check, or will have to
// make less broad rules